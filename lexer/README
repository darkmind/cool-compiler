README file for Programming Assignment 1 (Java edition)
=======================================================

Write-up for PA1J
-----------------

Jay Patel <jayhp9>
Yushi Wang <yushiw>

##########Design##########

Firstly, we used four states for parsing: 
i) 	YYINITIAL - the default state of reading code
ii) 	BLOCK_COMMENT - used when one or more "(*" comment symbols are open.
iii) 	STRING - used when the lexer reads double-quote in YYINITIAL, which 
	indicates the start of a string constant.
iv) 	BAD_STRING - used to when an error is detected in state STRING

Between these four states, we hoped to catch all possible situations of lexing.
----------------------------------------
YYINITIAL

Firstly, under YYINITIAL, all tokens are separated by whitespace of any type. 
In addition, every time we see a '\n' (new line), we increment the global 
variable curr_lineno, which keeps track of the number of lines in the program. 
This second rule is also found in each of the other states.

When we're parsing the program in "normal mode", most of the rules and 
expressions that we catch are fairly straightforward. We create a rule for each 
of our syntactic symbols ('{', ')', etc.), and case-insensitive keywords 
("class", "else", etc.) where if we match one of these we can directly return a 
new Symbol() with the appropriate TokenConstants constant and no lexeme. If we 
detect "true" or "false" (case insensitive on all but the first character), then
we return the token constant BOOL_CONST and lexeme matching the boolean.

A rule was made for each of type identifiers and object identifiers, which are 
both tokens beginning with a letter and followed by a combination of digits, 
'_', and letters. The case of the first letter determines whether it's a type or
object. When we parse an identifier, we put it in the idtable and return the 
appropriate token constant (TYPEID, OBJECTID) along with the returned abstract 
symbol as a lexeme.

We defined integers any string of only digits, and every time we catch one, we 
put the integer in the inttable and return the constant INT_CONST and the 
abstract symbol.

If we hit any character that can't be matched anywhere, then we throw an error 
for undefined syntax.

To handle comments and strings, we use different states.
----------------------------------------
COMMENTS

There were two types of comments: inline and block comments. Inline comments, 
which only matter in the YYINITIAL state, are simple to take care of: create a 
rule for "--" followed by any number of non-line terminating characters. When we
find this, we simply ignore it and move on. This comments out one line.

To detect block comments, we needed a method of detecting open "(*" strings. To 
do this, we made a rule in both YYINITIAL and BLOCK_COMMENT, when "(*" signifies
 a (nested) block comment, in which we increment a global variable 
num_nested_comments that keeps track of the number of nested block comment 
layers. When this variable is positive, we are in a block comment, and thus 
parse everything as though it were commented out.

While in the BLOCK_COMMENT state, every character is ignored except for the pair
"*)", which signifies the end of a block comment, so we decrement 
num_nested_comments. When it reaches 0, we return to YYINITIAL. However, if we 
see "*)" while in YYINITIAL, this means we found an unmatched "*)", so we throw 
an error.
----------------------------------------
STRINGS

When we read a double-quotes (") character while in YYINITIAL, we know that 
we're going to start reading a string. While in the STRING state, we have a 
string buffer which we add all valid characters (non null, line terminating, or 
eof). Every time we add a character, we also increase a global variable 
curr_strLen, which keeps track of the string's length. There is a small 
exception where if we read a backslash, then this escapes the next character, so
if the next character is t, f, n, or b, we replace it with the correct character

Our string is valid if it doesn't encounter one of the three errors, found 
below, and it encounters closing quotes, at which point we add our string to the
 string table, and return the constant STRING_CONST and proper lexeme.

There are 3 errors that can happen while in the STRING state:
i) Missing quotes
ii) String is too long (our counter goes above the limit)
iii) String contains the null character '\0'

In the first case, if we hit a line terminator before quotes, we scrap our 
string and return an appropriate error. In the other two, we return an error and
go to state BAD_STRING, in which every character except quotes and the line 
terminator is ignored. When BAD_STRING encounters one of these two, then the 
string has ended, so it returns to YYINITIAL and doesn't return anything (since 
we already returned an error).
----------------------------------------
At the end of our program, if we're in the YYINITIAL state, then all is good, so
we don't do anything. If we're in any of the other states (BLOCK_COMMENT, 
STRING, BAD_STRING), then we throw an error and go back to YYINITIAL.
